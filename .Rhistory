qqline(residuals_log, col = "red")
# Calculate the average metrics across all folds
mae_avg <- mean(mae_values)
mse_avg <- mean(mse_values)
rmse_avg <- mean(rmse_values)
return(list(mae = mae_avg, mse = mse_avg, rmse = rmse_avg))
}
# Prepare dataset and target variable
data <- airquality_transformed[, !(names(airquality_transformed) %in% c("C6H6_GT"))]
target <- airquality_transformed$C6H6_GT
# Perform cross-validation
cv_results <- cv_linear_model(data, target)
#### k-5 cross validation ####
### Cross-Validation for Linear Regression in Time Series ###
# Define expanding window cross-validation
folds <- 10  # Number of cross-validation folds
# Function to perform cross-validation
cv_linear_model <- function(data, target, folds) {
n <- nrow(data)
fold_size <- floor(n / folds)
mae_values <- c()
mse_values <- c()
rmse_values <- c()
for (i in 1:folds) {
# Define training and testing indices for each fold
train_index <- 1:(fold_size * i)
test_index <- (fold_size * i + 1):min(n, fold_size * (i + 1))
train_data <- data[train_index, ]
train_y <- target[train_index]
test_data <- data[test_index, ]
test_y <- target[test_index]
# Fit linear model for each fold
linear_model <- lm(train_y ~ ., data = train_data)
# Make predictions on the test set for each fold
y_pred_linear <- predict(linear_model, newdata = test_data)
# Back-transform predictions to the original scale
y_pred_linear_backtransformed <- exp(y_pred_linear) - 1
test_y_backtransformed <- exp(test_y) - 1
# Calculate evaluation metrics
mae_values <- c(mae_values, mae(test_y_backtransformed, y_pred_linear_backtransformed))
mse_values <- c(mse_values, mse(test_y_backtransformed, y_pred_linear_backtransformed))
rmse_values <- c(rmse_values, rmse(test_y_backtransformed, y_pred_linear_backtransformed))
}
# Perform Residual Analysis after cross-validation
residuals_log <- target - predict(lm(target ~ ., data = data))
# Plot Residuals vs Fitted (Log Scale)
fitted_values <- predict(lm(target ~ ., data = data))
plot(fitted_values, residuals_log,
main = "Residuals vs Fitted (Log Scale)",
xlab = "Fitted Values (Log Scale)",
ylab = "Residuals (Log Scale)")
abline(h = 0, col = "red")
# Check normality of residuals using Q-Q plot (Log Scale)
qqnorm(residuals_log, main = "Q-Q Plot of Residuals (Log Scale)")
qqline(residuals_log, col = "red")
# Calculate the average metrics across all folds
mae_avg <- mean(mae_values)
mse_avg <- mean(mse_values)
rmse_avg <- mean(rmse_values)
return(list(mae = mae_avg, mse = mse_avg, rmse = rmse_avg))
}
# Prepare dataset and target variable
data <- airquality_transformed[, !(names(airquality_transformed) %in% c("C6H6_GT"))]
target <- airquality_transformed$C6H6_GT
# Split the data into training and testing sets (70% training, 30% testing)
train_size <- floor(0.7 * nrow(data))
train_data <- data[1:train_size, ]
train_target <- target[1:train_size]
test_data <- data[(train_size + 1):nrow(data), ]
test_target <- target[(train_size + 1):nrow(target)]
# Create a sequence index for plotting
index <- 1:nrow(data)
# Extract training and testing data for visualization
train_target_full <- target[1:train_size]  # Training data (target)
test_target_full <- target[(train_size + 1):nrow(data)]  # Testing data (target)
# Train-Test Split Visualization
plot(index, target, type = "n",
main = "Train-Test Split Visualization",
xlab = "Time Index",
ylab = "Target Variable (Log-Transformed)")
# Training set blue line
lines(index[1:train_size], train_target_full, col = "blue", lwd = 2)
# Test set red line
lines(index[(train_size + 1):nrow(data)], test_target_full, col = "red", lwd = 2)
legend("topright", legend = c("Training Set", "Test Set"),
col = c("blue", "red"), lty = 1, lwd = 2)
# Perform cross-validation
cv_results <- cv_linear_model(data, target, folds)
#### k-5 cross validation ####
### Cross-Validation for Linear Regression in Time Series ###
# Define expanding window cross-validation
folds <- 10  # Number of cross-validation folds
# Function to perform cross-validation
cv_linear_model <- function(data, target, folds) {
n <- nrow(data)
fold_size <- floor(n / folds)
mae_values <- c()
mse_values <- c()
rmse_values <- c()
for (i in 1:folds) {
# Define training and testing indices for each fold
train_index <- 1:(fold_size * i)
test_index <- (fold_size * i + 1):min(n, fold_size * (i + 1))
train_data <- data[train_index, ]
train_y <- target[train_index]
test_data <- data[test_index, ]
test_y <- target[test_index]
# Fit linear model for each fold
linear_model <- lm(train_y ~ ., data = train_data)
# Make predictions on the test set for each fold
y_pred_linear <- predict(linear_model, newdata = test_data)
# Back-transform predictions to the original scale
y_pred_linear_backtransformed <- exp(y_pred_linear) - 1
test_y_backtransformed <- exp(test_y) - 1
# Calculate evaluation metrics
mae_values <- c(mae_values, mae(test_y_backtransformed, y_pred_linear_backtransformed))
mse_values <- c(mse_values, mse(test_y_backtransformed, y_pred_linear_backtransformed))
rmse_values <- c(rmse_values, rmse(test_y_backtransformed, y_pred_linear_backtransformed))
}
# Perform Residual Analysis after cross-validation
residuals_log <- target - predict(lm(target ~ ., data = data))
# Plot Residuals vs Fitted (Log Scale)
fitted_values <- predict(lm(target ~ ., data = data))
plot(fitted_values, residuals_log,
main = "Residuals vs Fitted (Log Scale)",
xlab = "Fitted Values (Log Scale)",
ylab = "Residuals (Log Scale)")
abline(h = 0, col = "red")
# Check normality of residuals using Q-Q plot (Log Scale)
qqnorm(residuals_log, main = "Q-Q Plot of Residuals (Log Scale)")
qqline(residuals_log, col = "red")
# Calculate the average metrics across all folds
mae_avg <- mean(mae_values)
mse_avg <- mean(mse_values)
rmse_avg <- mean(rmse_values)
return(list(mae = mae_avg, mse = mse_avg, rmse = rmse_avg))
}
# Prepare dataset and target variable
data <- airquality_transformed[, !(names(airquality_transformed) %in% c("C6H6_GT"))]
target <- airquality_transformed$C6H6_GT
# Perform cross-validation
cv_results <- cv_linear_model(data, target, folds)
# Print Cross-Validation results
print(paste("Average MAE (original scale):", cv_results$mae))
print(paste("Average MSE (original scale):", cv_results$mse))
print(paste("Average RMSE (original scale):", cv_results$rmse))
#### Perform Cross-Validation for linear model ####
#### Train/Test Split (These steps were already done previously and remain unchanged) ####
# Split the train and test split: 70% for training, 30% for testing
train_size <- floor(0.7 * nrow(airquality_transformed))
train_data <- airquality_transformed[1:train_size, ]
# Perform cross-validation
cv_results <- cv_linear_model(data, target, folds)
# Print Cross-Validation results
print(paste("Average MAE (original scale):", cv_results$mae))
print(paste("Average MSE (original scale):", cv_results$mse))
print(paste("Average RMSE (original scale):", cv_results$rmse))
#### k-5 cross validation ####
### Cross-Validation for Linear Regression in Time Series ###
# Define expanding window cross-validation
folds <- 10  # Number of cross-validation folds
# Function to perform cross-validation
cv_linear_model <- function(data, target, folds) {
n <- nrow(data)
fold_size <- floor(n / folds)
mae_values <- c()
mse_values <- c()
rmse_values <- c()
for (i in 1:folds) {
# Define training and testing indices for each fold
train_index <- 1:(fold_size * i)
test_index <- (fold_size * i + 1):min(n, fold_size * (i + 1))
train_data <- data[train_index, ]
train_y <- target[train_index]
test_data <- data[test_index, ]
test_y <- target[test_index]
# Fit linear model for each fold
linear_model <- lm(train_y ~ ., data = train_data)
# Make predictions on the test set for each fold
y_pred_linear <- predict(linear_model, newdata = test_data)
# Back-transform predictions to the original scale
y_pred_linear_backtransformed <- exp(y_pred_linear) - 1
test_y_backtransformed <- exp(test_y) - 1
# Calculate evaluation metrics
mae_values <- c(mae_values, mae(test_y_backtransformed, y_pred_linear_backtransformed))
mse_values <- c(mse_values, mse(test_y_backtransformed, y_pred_linear_backtransformed))
rmse_values <- c(rmse_values, rmse(test_y_backtransformed, y_pred_linear_backtransformed))
}
# Perform Residual Analysis after cross-validation
residuals_log <- target - predict(lm(target ~ ., data = data))
# Plot Residuals vs Fitted (Log Scale)
fitted_values <- predict(lm(target ~ ., data = data))
plot(fitted_values, residuals_log,
main = "Residuals vs Fitted (Log Scale)",
xlab = "Fitted Values (Log Scale)",
ylab = "Residuals (Log Scale)")
abline(h = 0, col = "red")
# Check normality of residuals using Q-Q plot (Log Scale)
qqnorm(residuals_log, main = "Q-Q Plot of Residuals (Log Scale)")
qqline(residuals_log, col = "red")
# Calculate the average metrics across all folds
mae_avg <- mean(mae_values)
mse_avg <- mean(mse_values)
rmse_avg <- mean(rmse_values)
return(list(mae = mae_avg, mse = mse_avg, rmse = rmse_avg))
}
# Prepare dataset and target variable
data <- airquality_transformed[, !(names(airquality_transformed) %in% c("C6H6_GT"))]
target <- airquality_transformed$C6H6_GT
# Perform cross-validation
cv_results <- cv_linear_model(data, target, folds)
# Print Cross-Validation results
print(paste("Average MAE (original scale):", cv_results$mae))
print(paste("Average MSE (original scale):", cv_results$mse))
print(paste("Average RMSE (original scale):", cv_results$rmse))
#### Perform Cross-Validation for linear model ####
#### Train/Test Split (These steps were already done previously and remain unchanged) ####
# Split the train and test split: 70% for training, 30% for testing
train_size <- floor(0.7 * nrow(airquality_transformed))
summary(cv_linear_model)
summary(cv_linear_model)
# Split data: 70% for training, 30% for testing
train_size <- floor(0.7 * nrow(airquality_transformed))
# Train-test split
train_data <- airquality_transformed[1:train_size, ]
test_data <- airquality_transformed[(train_size + 1):nrow(airquality_transformed), ]
train_y <- train_data$C6H6_GT  # Target variable for training
train_data <- train_data[, !(names(train_data) %in% c("C6H6_GT"))]  # Training features
# 10-Fold Cross-Validation Setup
train_control <- trainControl(method = "cv", number = 10)
# Fit model with cross-validation
linear_model_cv <- train(train_y ~ ., data = train_data,
method = "lm", trControl = train_control)
print(linear_model_cv)
# Combine train_y with train_data into a single data frame
train_data_combined <- cbind(train_y = train_y, train_data)
# 10-Fold Cross-Validation Setup
train_control <- trainControl(method = "cv", number = 10)
# Fit model with cross-validation
linear_model_cv <- train(train_y ~ ., data = train_data_combined,
method = "lm", trControl = train_control)
print(linear_model_cv)
# Evaluate model on test data
test_y <- test_data$C6H6_GT  # Target variable for testing
test_data <- test_data[, !(names(test_data) %in% c("C6H6_GT"))]  # Testing features
# Make predictions on the test set using the model trained with cross-validation
y_pred_linear <- predict(linear_model_cv, newdata = test_data)
### Residual Analysis (Log Scale) ###
residuals_log <- test_y - y_pred_linear
# Plot Residuals vs Fitted (Log Scale) after cross-validation
plot(y_pred_linear, residuals_log,
main = "Residuals vs Fitted (Log Scale)",
xlab = "Fitted Values (Log Scale)",
ylab = "Residuals (Log Scale)")
abline(h = 0, col = "red")
# Check normality of residuals with Q-Q Plot (Log Scale)
qqnorm(residuals_log, main = "Q-Q Plot of Residuals (Log Scale)")
qqline(residuals_log, col = "red")
### Predictions and Back Transformation ###
# Back-transform predictions to the original scale
y_pred_linear_backtransformed <- exp(y_pred_linear) - 1
test_y_backtransformed <- exp(test_y) - 1
# Define evaluation metrics
mae <- function(actual, predicted) {
mean(abs(actual - predicted))
}
mse <- function(actual, predicted) {
mean((actual - predicted)^2)
}
rmse <- function(actual, predicted) {
sqrt(mean((actual - predicted)^2))
}
# Calculate evaluation metrics on the original scale
mae_value <- mae(test_y_backtransformed, y_pred_linear_backtransformed)
mse_value <- mse(test_y_backtransformed, y_pred_linear_backtransformed)
rmse_value <- rmse(test_y_backtransformed, y_pred_linear_backtransformed)
# Print results
print(paste("MAE (original scale):", mae_value))
print(paste("MSE (original scale):", mse_value))
print(paste("RMSE (original scale):", rmse_value))
### Visualization: Train-Test Split ###
index <- 1:nrow(airquality_transformed)
train_y_full <- airquality_transformed$C6H6_GT[1:train_size]  # Training data (C6H6_GT)
test_y_full <- airquality_transformed$C6H6_GT[(train_size + 1):nrow(airquality_transformed)]  # Testing data (C6H6_GT)
plot(index, airquality_transformed$C6H6_GT, type = "n",
main = "Train-Test Split Visualization for C6H6_GT",
xlab = "Time Index",
ylab = "C6H6_GT (Log-Transformed)")
# Training set blue line
lines(index[1:train_size], train_y_full, col = "blue", lwd = 2)
# Test set red line
lines(index[(train_size + 1):nrow(airquality_transformed)], test_y_full, col = "red", lwd = 2)
legend("topright", legend = c("Training Set", "Test Set"),
col = c("blue", "red"), lty = 1, lwd = 2)
####################################################
# Define evaluation metrics
mae <- function(actual, predicted) {
mean(abs(actual - predicted))
}
mse <- function(actual, predicted) {
mean((actual - predicted)^2)
}
rmse <- function(actual, predicted) {
sqrt(mean((actual - predicted)^2))
}
# Set up 10-fold cross-validation
train_control <- trainControl(method = "cv", number = 10)
# Fit linear regression model with cross-validation
cross_val_model <- train(C6H6_GT ~ ., data = airquality_transformed, method = "lm", trControl = train_control)
# Get model summary
summary(cross_val_model$finalModel)
# Predictions from cross-validation
cv_predictions <- cross_val_model$pred
cv_residuals <- cv_predictions$obs - cv_predictions$pred
# Calculate evaluation metrics from cross-validation
mae_cv <- mae(cv_predictions$obs, cv_predictions$pred)
mse_cv <- mse(cv_predictions$obs, cv_predictions$pred)
rmse_cv <- rmse(cv_predictions$obs, cv_predictions$pred)
# Print the evaluation metrics
cat("\nCross-Validation Results:\n")
print(paste("MAE:", mae_cv))
print(paste("MSE:", mse_cv))
print(paste("RMSE:", rmse_cv))
# Q-Q plot for residuals
qqnorm(cv_residuals, main = "Q-Q Plot of Residuals (Cross-Validation)")
# Define evaluation metrics
mae <- function(actual, predicted) {
mean(abs(actual - predicted), na.rm = TRUE)
}
mse <- function(actual, predicted) {
mean((actual - predicted)^2, na.rm = TRUE)
}
rmse <- function(actual, predicted) {
sqrt(mean((actual - predicted)^2, na.rm = TRUE))
}
# Set up 10-fold cross-validation
train_control <- trainControl(method = "cv", number = 10)
# Fit linear regression model with cross-validation
cross_val_model <- train(C6H6_GT ~ ., data = airquality_transformed, method = "lm", trControl = train_control)
# Get model summary
summary(cross_val_model$finalModel)
# Predictions from cross-validation
cv_predictions <- na.omit(cross_val_model$pred)  # Remove any NA values
cv_residuals <- cv_predictions$obs - cv_predictions$pred
# Calculate evaluation metrics from cross-validation
mae_cv <- mae(cv_predictions$obs, cv_predictions$pred)
mse_cv <- mse(cv_predictions$obs, cv_predictions$pred)
rmse_cv <- rmse(cv_predictions$obs, cv_predictions$pred)
# Print the evaluation metrics
cat("\nCross-Validation Results:\n")
print(paste("MAE:", mae_cv))
print(paste("MSE:", mse_cv))
print(paste("RMSE:", rmse_cv))
# Q-Q plot for residuals
if (length(cv_residuals) > 0) {
qqnorm(cv_residuals, main = "Q-Q Plot of Residuals (Cross-Validation)")
qqline(cv_residuals, col = "red")
} else {
cat("\nNo residuals available for Q-Q plot.\n")
}
# Define evaluation metrics
mae <- function(actual, predicted) {
mean(abs(actual - predicted), na.rm = TRUE)
}
mse <- function(actual, predicted) {
mean((actual - predicted)^2, na.rm = TRUE)
}
rmse <- function(actual, predicted) {
sqrt(mean((actual - predicted)^2, na.rm = TRUE))
}
# Set up 10-fold cross-validation
train_control <- trainControl(method = "cv", number = 10, savePredictions = "final")
# Fit linear regression model with cross-validation
cross_val_model <- train(C6H6_GT ~ ., data = airquality_transformed, method = "lm", trControl = train_control)
# Get model summary
summary(cross_val_model$finalModel)
# Predictions from cross-validation
cv_predictions <- na.omit(cross_val_model$pred)  # Remove any NA values
# Check if there are any valid predictions available
if (nrow(cv_predictions) > 0) {
cv_residuals <- cv_predictions$obs - cv_predictions$pred
# Calculate evaluation metrics from cross-validation
mae_cv <- mae(cv_predictions$obs, cv_predictions$pred)
mse_cv <- mse(cv_predictions$obs, cv_predictions$pred)
rmse_cv <- rmse(cv_predictions$obs, cv_predictions$pred)
# Print the evaluation metrics
cat("\nCross-Validation Results:\n")
print(paste("MAE:", mae_cv))
print(paste("MSE:", mse_cv))
print(paste("RMSE:", rmse_cv))
# Q-Q plot for residuals
qqnorm(cv_residuals, main = "Q-Q Plot of Residuals (Cross-Validation)")
qqline(cv_residuals, col = "red")
# Scatter plot of residuals vs fitted values
plot(cv_predictions$pred, cv_residuals,
main = "Residuals vs Fitted Values (Cross-Validation)",
xlab = "Fitted Values",
ylab = "Residuals")
abline(h = 0, col = "red")
} else {
cat("\nNo residuals available for analysis. Cross-validation predictions contain only NA values.\n")
}
#### Perform Cross-Validation for linear model ####
#### Train/Test Split (These steps were already done previously and remain unchanged) ####
# Split the train and test split: 70% for training, 30% for testing
train_size <- floor(0.7 * nrow(airquality_transformed))
train_data <- airquality_transformed[1:train_size, ]
####################################################
# Define the cross-validation control with 10 folds
train_control <- trainControl(method = "cv", number = 10)
# Train the linear model with cross-validation on the transformed data
cross_val_model <- train(
C6H6_GT ~ .,
data = airquality_transformed,
method = "lm",
trControl = train_control
)
# Display the cross-validation results
print(cross_val_model)
# Extract metrics
cross_val_summary <- summary(cross_val_model$finalModel)
print(cross_val_summary)
# Predict on the test set using the cross-validated model
cross_val_predictions <- predict(cross_val_model, newdata = test_data)
# Back-transform predictions to the original scale
cross_val_pred_backtransformed <- exp(cross_val_predictions) - 1
test_y_backtransformed <- exp(test_y) - 1
# Calculate evaluation metrics on the original scale
mae_cross_val <- mae(test_y_backtransformed, cross_val_pred_backtransformed)
mse_cross_val <- mse(test_y_backtransformed, cross_val_pred_backtransformed)
rmse_cross_val <- rmse(test_y_backtransformed, cross_val_pred_backtransformed)
# Print results
print(paste("Cross-Validation MAE (original scale):", mae_cross_val))
print(paste("Cross-Validation MSE (original scale):", mse_cross_val))
print(paste("Cross-Validation RMSE (original scale):", rmse_cross_val))
# Calculate residuals on log-transformed scale
residuals_log_cross_val <- test_y - cross_val_predictions
# Q-Q Plot of residuals (log scale)
qqnorm(residuals_log_cross_val, main = "Q-Q Plot of Residuals (Cross-Validation, Log Scale)")
qqline(residuals_log_cross_val, col = "red")
# Scatter plot of residuals vs fitted values (log scale)
plot(cross_val_predictions, residuals_log_cross_val,
main = "Residuals vs Fitted (Cross-Validation, Log Scale)",
xlab = "Fitted Values (Log Scale)",
ylab = "Residuals (Log Scale)")
abline(h = 0, col = "red")
#### Perform Cross-Validation for linear model ####
#### Train/Test Split (These steps were already done previously and remain unchanged) ####
# Split the train and test split: 70% for training, 30% for testing
train_size <- floor(0.7 * nrow(airquality_transformed))
#### k-5 cross validation ####
### Cross-Validation for Linear Regression in Time Series ###
# Define expanding window cross-validation
folds <- 10  # Number of cross-validation folds
# Function to perform cross-validation
cv_linear_model <- function(data, target, folds) {
n <- nrow(data)
fold_size <- floor(n / folds)
mae_values <- c()
mse_values <- c()
rmse_values <- c()
for (i in 1:folds) {
# Define training and testing indices for each fold
train_index <- 1:(fold_size * i)
test_index <- (fold_size * i + 1):min(n, fold_size * (i + 1))
train_data <- data[train_index, ]
train_y <- target[train_index]
test_data <- data[test_index, ]
test_y <- target[test_index]
# Fit linear model for each fold
linear_model <- lm(train_y ~ ., data = train_data)
# Make predictions on the test set for each fold
y_pred_linear <- predict(linear_model, newdata = test_data)
# Back-transform predictions to the original scale
y_pred_linear_backtransformed <- exp(y_pred_linear) - 1
test_y_backtransformed <- exp(test_y) - 1
# Calculate evaluation metrics
mae_values <- c(mae_values, mae(test_y_backtransformed, y_pred_linear_backtransformed))
mse_values <- c(mse_values, mse(test_y_backtransformed, y_pred_linear_backtransformed))
rmse_values <- c(rmse_values, rmse(test_y_backtransformed, y_pred_linear_backtransformed))
}
# Perform Residual Analysis after cross-validation
residuals_log <- target - predict(lm(target ~ ., data = data))
# Plot Residuals vs Fitted (Log Scale)
fitted_values <- predict(lm(target ~ ., data = data))
plot(fitted_values, residuals_log,
main = "Residuals vs Fitted (Log Scale)",
xlab = "Fitted Values (Log Scale)",
ylab = "Residuals (Log Scale)")
abline(h = 0, col = "red")
# Check normality of residuals using Q-Q plot (Log Scale)
qqnorm(residuals_log, main = "Q-Q Plot of Residuals (Log Scale)")
qqline(residuals_log, col = "red")
# Calculate the average metrics across all folds
mae_avg <- mean(mae_values)
mse_avg <- mean(mse_values)
rmse_avg <- mean(rmse_values)
return(list(mae = mae_avg, mse = mse_avg, rmse = rmse_avg))
}
# Prepare dataset and target variable
data <- airquality_transformed[, !(names(airquality_transformed) %in% c("C6H6_GT"))]
target <- airquality_transformed$C6H6_GT
# Perform cross-validation
cv_results <- cv_linear_model(data, target, folds)
# Print Cross-Validation results
print(paste("Average MAE (original scale):", cv_results$mae))
print(paste("Average MSE (original scale):", cv_results$mse))
print(paste("Average RMSE (original scale):", cv_results$rmse))
# Print results
print(paste("Cross-Validation MAE (original scale):", mae_cross_val))
print(paste("Cross-Validation MSE (original scale):", mse_cross_val))
print(paste("Cross-Validation RMSE (original scale):", rmse_cross_val))
